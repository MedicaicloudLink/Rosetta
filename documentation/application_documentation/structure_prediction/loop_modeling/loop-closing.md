# Loop Closing

Loop Closing is related to, but not identical with, [[Loop Modeling|loopmodel]] protocols. Loop Closing is dedicated to close a non-physical chainbreak introduced during
broken-chain (jumping) fragment assembly, whereas Loop Modeling first introduces a chain-break to improve sampling in a loop-region and subsequently removes that same chainbreak again. Note, that loop-building benchmarks are generally performed on crystal structures where only a single loop is perturbed. We found that even small perturbations of the structural core as present in de-novo generated structures are a huge game-changer. Accordingly, we found that applying the standard loop-modeling protocols (e.g., CCD, KIC) of Rosetta did not perform well in the context of the de-novo structure generation protocols.
If multiple chainbreaks are present, loop-closing will be carried out for each chain-break individually. When attempting to close a loop while other chainbreaks are present the sampling of backbone torsions is restricted to the area around the chainbreak that doesn't contain any other jump residues. These are free ends (leaves) in the FoldTree. When selecting which chainbreak to close first, we select those first that have longer free ends, because their removal will also reduce the number of jump-residues and thus might free up other chainbreaks free ends. 

#### The Sliding Window Protocol

[[/images/sliding_windows.jpg]]

For a given chainbreak we then generate windows of varying length with different offsets to the chainbreak position in the hope to find the optimal stretch of (loop) residues around the chainbreak which can best accomodate a conformation that closes the loop with ideal bond lengths and angles (Figure). The general protocol is implemented in class SlidingWindowLoopClosure. The windows are sorted by size and sampled starting with the smallest windows. For each window 200 loop-conformations are generated using fragment assembly. The first 100 conformations are sampled without scoring using a Pose that is reduced to the sampled loop and its two anchor residues. The second 100 conformations are generated using a reduced ScoreFunction defined in loop_fragsample.wts (rosetta_database: vdw=1.0, pair=1.0, env=1.0, linear_chainbreak=1.0, overlap_chainbreak=1.0) but are sampled in the context of the full Pose.
The conformations generated in windows with different length and offset are filtered to exclude conformations with horrible clashes and then rescored with the full ScoreFunction as it was used in the previous fragment assembly (abinitio) stage (including the restraint scores). The best scoring loop-conformation is selected if it out-competes the starting conformation (which has been stored, too).

#### The Faster BreadthFirstSlidingWindowLoopClosure

This protocol is activated by the flag -loops:alternative_closure_protocol.
Benchmarking showed that we were able to speed up the SlidingWindow protocol considerably without loss of performance by first searching quickly through all windows of different size and offset to find those that are amenable to closing. Then subsequently, we would focus the more thorough sampling on those preselected windows. Thus, the breadth first algorithm first performs the fast unscored sampling in the reduced Pose on all windows and then proceeds to sample with scoring (loop_fragsample.wts) only those windows that yielded a set ratio (-fast_loops:window_accept_ratio) of acceptable loop conformations in the unscored sampling.

#### Loop Closing by Idealization

Our results also showed that the ROSETTA idealization protocol can be an efficient loop-closer if the starting decoys loops are already sufficiently close to an ideally closed conformation. The latter is often the case if the RASREC sampling protocol is used in conjunction with the linear_chainbreak and the overlap_chainbreak scores. The flags -loops:idealize_before_loop_close and -loops:idealize_after_loop_close trigger the idealization protocol before and after the fragment based loop-closing protocol described above is executed. If idealization is executed before loop closing the idealized starting conformation often out-competes (by score) the newly generated conformations and is selected in these cases. We also found that if the idealization protocol is able to produce a high quality conformation with low scores it is often more accurate than the conformations generated by fragment based loop-sampling. If idealization did not succeed before dedicated loop-closing it usually has significantly higher chances to succeed after loop-closing. Moreover, if the structure is already close to ideal the idealization protocol requires less time to run such that it is still efficient to run idealization before and after loop closing. Moreover, running idealization after loop-closing allows us to skip the execution of the CCD loop-closer which (nearly always) finds an ideal (but often crappy) conformation solving the kinematic equations. Hence, we found it superior to run loop-closing with the flags -loops:non_ideal_loop_closing (skipping the ccd step) and -loops:idealize_after_loop_close. 

##See Also

* [[Loopmodel]]: The loopmodel application page
* [[Structure prediction applications]]: A list of other applications to be used for structure prediction, including loop modeling
* [[Loops file]]: File format for specifying loops for loop modeling
* [[Loop modeling algorithms|loopmodel-algorithms]]
* [[Application Documentation]]: List of Rosetta applications
* [[Running Rosetta with options]]: Instructions for running Rosetta executables.
* [[Comparing structures]]: Essay on comparing structures
* [[Analyzing Results]]: Tips for analyzing results generated using Rosetta
* [[Solving a Biological Problem]]: Guide to approaching biological problems using Rosetta
* [[Commands collection]]: A list of example command lines for running Rosetta executable files




