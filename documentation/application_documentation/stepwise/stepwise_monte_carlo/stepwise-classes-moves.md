#StepWise Moves & Monte Carlo
# Code
Basic code running stepwise monte carlo is in `src/protocols/stepwise/monte_carlo/StepWiseMonteCarlo.hh`.

# How to run it
----------------
(see, e.g., `src/apps/public/stepwise/stepwise.cc`)
```
	StepWiseMonteCarlo stepwise_monte_carlo( scorefxn );

	StepWiseMonteCarloOptionsOP options = new StepWiseMonteCarloOptions;
	stepwise_monte_carlo.set_options( options );

	stepwise_monte_carlo.apply( pose );
```

# General Monte Carlo scheme
----------------------------
The stepwise Monte Carlo method generates low-energy conformations of the modeled regions through a recursive application of six basic kinds of moves. Given a single chain of nucleotides, a model is built recursively through cycles of single-nucleotide modeling at the 5’ and 3’ chain termini, culminating in the connection of the two growing strands. A single Monte Carlo cycle is defined as follows:

 - A move, defined by its move type and the residue to which it will be applied, is chosen at random in a move selection step.
 - The move is then applied (i.e. coordinates of the residue(s) are instantiated, resampled, or deleted) in a move application step. 
 - The degrees of freedom affected by the move are resampled, screened and filtered during modeling. This and the next step are the same as in the previously published stepwise assembly procedure {sripakdeevong, 2011}, except that, here, the resampling step involves the discovery of 20 random torsion combinations that pass filters, and not a complete enumeration of all such torsion combinations. The lowest energy of those 20 is passed to the next step.
 - The resulting model is minimized in a minimization step. (The stepwise application also allows a choice of passing through several models, which are clustered, minimized, and re-clustered; this mode is used in the previous stepwise assembly enumeration procedure.)
 - The lowest energy model is selected, and its energy is compared to the energy of the model generated by the previous step, and the new model is either accepted or rejected based on the Metropolis criterion; if the new model has a lower energy it is accepted.


# Move Selection
----------------
A concise description of a move is given as a `StepWiseMove`. The types of moves are the following (see `src/protocols/stepwise/monte_carlo/mover/stepwise_move.hh`:

 - `ADD` -- _Addition_ moves are defined by supplying the sequence position(s) of one or more residues, not yet instantiated, to be added to a 5’ or 3’ chain terminus in the current pose. If a single covalent connection can be drawn from the existing pose to the residue (i to i+1), then the addition will be made through a covalent bond. Otherwise, the residue will be added by a jump; as in prior work, we typically only allow jumps separated by a single residue (i to i+2). We found that these residue-skipping moves were not necessary to stepwise monte carlo modeling, and the mode was disabled during the benchmarking runs presented in the main text (the “skip-bulge” mode, disabled by default, can be activated via the “-allow_skip_bulge” command-line option) For problems that involve tertiary interaction of two chains, addition moves can also specify docking.
 
 - `DELETE` -- _Deletion_ moves are defined by supplying the sequence position(s) of one or more previously-instantiated residues, located at a 5’ or 3’ chain terminus, to be removed from the existing pose. If the residues to be deleted include more than one contiguous residue, then the pose is split, and the removed residues are kept in a list of “other” poses held inside the pose of interest. The physical interpretation of these separate poses is that they are the well-structured regions of the molecule whose connections have not been defined through inter-region contacts. For problems that involve tertiary interaction of two chains, deletion moves can also specify splitting of the two chains.

 - `FROM_SCRATCH` -- create a dinucleotide or dipeptide from scratch. The resulting pose is kept in the list of "other" poses until a covalent connection to the pose in focus is sampled. 

 - `RESAMPLE` -- _Resample_ moves involve sampling a specific existing connection. The move is defined by specifying the sequence position of a residue to move, and the connection is inferred based on the parent residue in the pose.

 - `RESAMPLE_INTERNAL_LOCAL` -- _Resample internal local_ moves sample a specific internal residue, making a transient cutpoint after it, enforcing KIC-based chain closure, and removing the cutpoint variant. This move is the same as is used in the ERRASER method for refining experimental density-guided structures {chou, 2013}, and, is in some ways analogous to the backrub move for proteins {richardson}{kortemme}.

 - `ADD_SUBMOTIF` -- _Submotif addition_ moves recognize small motifs, stored in a pre-compiled Rosetta database, that match a subset of uninstantiated residues in the pose, and incorporate crystallographic conformations of matching motifs into the pose.  Only submotifs that can be added through a single covalent connection to the existing pose are considered. Currently, the database of submotifs is limited to C-G Watson-Crick pairs, U-A noncanonical W/H pairs, G-G noncanonical W/H pairs, and U-turns.
 
For each move, the residue and parent residue must are specified, as well as the type of connection to be made between in the residue and its parent. These attachment types include ‘bond to previous’, ‘bond to next’, ‘jump to previous in chain’, ‘jump to next in chain’, and ‘jump dock’. The parent residue and attachment type are represented as an `Attachment` object, stored inside the `StepWiseMove` object.

Given the structure at its current state, all of the possible moves out of this state are determined, with move frequencies balanced so that resample, from scratch, and docking moves occur with frequencies of 0.5, 0.2, and 0.2 relative to addition and deletion moves. From the list of all possible moves, a single move can be selected using a random number generator. This functionality is encapsulated in a single `StepWiseMoveSelector` object.

A `StepWiseMasterMover` object is responsible for initializing and applying the `StepWiseMoveSelector` described above. After all of the possible moves are figured out, a random number is generated and used to select one of the possible moves. Once selected, the `StepWiseMasterMover` is responsible for applying the move to the pose. Additionally, the `StepWiseMasterMover` handles proposal ratios (see below) and ensures that all reverse moves are possible. Although the use of continuous minimization here precludes exact detailed balance, these features would allow maintenance of detailed balance in future extensions of stepwise monte carlo.

[*Experimental* For design, also testing `ADD_LOOP_RES` and `DELETE_LOOP_RES` moves that don't change pose but instead the assumed loop lengths.]

# Move application
------------------

Given the current pose and a `StepWiseMove` object, the core functionality of these movers involve mapping the moving and attachment residues defined in the `StepWiseMove` to the pose, and using this information to carry out the application of the move. For moves that involve the instantiation of nucleotide(s), their associated mover is also responsible for initializing the torsions of the instantiated residue(s). While pre-sampling of residue conformations is handled by some movers, the core conformational sampling occurs during the modeling stage (see below). 

The `StepWiseMoasterMover` described above is responsible for initialization and application of these various move-specific movers. Given a selected `StepWiseMove`, the `StepWiseMasterMover` maps the move’s type to its corresponding mover (e.g. `StepWiseMove::move_type` “RESAMPLE” maps to the `ResampleMover`), and calls the mover’s `::apply()` function on the current `Pose`. In some cases, a more general mover provides an additional layer of abstraction between the `StepWiseMover` and move-specific mover. For example, `StepWiseMove::move_type`s “ADD”, “DELETE”, “FROM_SCRATCH”, and “ADD_SUBMOTIF” all map to an `AddOrDeleteMover`; this intermediate mover makes a choice, based on the current `Pose` and `StepWiseMove`, as to whether to add or delete a single nucleotide or chunk of nucleotides, and where.

# How to do a specific move
---------------------------

```
AddMover add_mover( scorefxn );
add_mover.set_presample_by_swa( true ); // will do the stepwise sampling.
add_mover.set_stepwise_modeler( new StepWiseModeler( scorefxn ) );
add_mover.apply( pose, 3 /*add res*/, 2 /*takeoff res*/ );   // imagine the pose has residues 1, 2, 7, 8
```

More examples of how to use these classes are in unit tests (`test/protocols/stepwise`)

---
Go back to [[StepWise Overview|stepwise-classes-overview]].

##See Also

* [[Stepwise options]]: Options classes for Stepwise code
* [[Writing an application|writing-an-app]]
* [[Development Documentation]]: The home page for development documentation
* [[Stepwise]]: The StepWise MonteCarlo application
* Applications for deterministic stepwise assembly:
  * [[Stepwise assembly for protein loops|swa-protein-main]]
    * [[Additional documentation|swa-protein-long-loop]]
  * [[RNA loop modeling with Stepwise Assembly|swa-rna-loop]]
* [[Structure prediction applications]]: Includes links to these and other applications for loop modeling
* [[RosettaScripts]]: The RosettaScripts home page
* [[Application Documentation]]: List of Rosetta applications
* [[Running Rosetta with options]]: Instructions for running Rosetta executables.
* [[Comparing structures]]: Essay on comparing structures
* [[Analyzing Results]]: Tips for analyzing results generated using Rosetta
* [[Solving a Biological Problem]]: Guide to approaching biological problems using Rosetta
* [[Commands collection]]: A list of example command lines for running Rosetta executable files
